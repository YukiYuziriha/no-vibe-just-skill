# Тестовое задание Polza — no-vibe-just-skill

## 1. Обзор

Этот репозиторий — небольшое, но аккуратно спроектированное решение тестового задания Polza:

1. **MX Checker** — читает файл со списком email-адресов и для каждого проверяет, существует ли домен и настроены ли MX-записи.
2. **Telegram Sender** — берёт текст из файла и отправляет его в приватный Telegram-чат через бота.
3. **ARCHITECTURE.md** — описывает архитектуру рассылки примерно на 1200 адресов в сутки с учётом стоимости, рисков и репутации доменов.

Цель кода — не «показать трюки», а вести себя как надёжный маленький сервис: явные таймауты, предсказуемые статусы, понятные ошибки и минимум лишних абстракций.

## 2. Структура проекта
```text
.
├── mx_checker.py        # Task 1: MX checker CLI
├── emails_example.txt   # Sample input for MX checker
├── telegram_sender.py   # Task 2: Telegram sender CLI
├── message_example.txt  # Sample input for Telegram sender
├── .env.example         # Example configuration for Telegram credentials
├── ARCHITECTURE.md      # Task 3: outreach system architecture
├── PLAN.md              # Original planning notes
├── README.md
└── requirements.txt     # dnspython, requests, python-dotenv
```

## 3. Требования и установка

- Установленный **Python 3.8+**.
- Доступен `pip` и модуль `venv` для создания виртуального окружения.

### 3.1. Установка Python, pip и venv

- **Windows**
  - Скачайте официальный установщик Python 3.x с сайта  
    `https://www.python.org/downloads/windows/`.
  - В инсталляторе обязательно поставьте галочку **“Add Python to PATH”**.
  - `pip` и поддержка виртуальных окружений (`venv`) будут установлены автоматически.

- **macOS**
  - Удобнее всего установить Python через Homebrew:
    ```bash
    brew install python
    ```
  - После этого будут доступны команды `python3`, `pip3` и модуль `venv`.

- **Linux (Debian / Ubuntu и похожие)**
  - Установите Python и необходимые пакеты:
    ```bash
    sudo apt update
    sudo apt install python3 python3-pip python3-venv
    ```

### 3.2. Виртуальное окружение и зависимости

Рекомендуется работать в отдельном виртуальном окружении, чтобы не загрязнять системный Python.

#### Windows

1. Откройте терминал в папке проекта:
   - Откройте папку в Проводнике.
   - В адресной строке введите `cmd` и нажмите Enter  
     *(или Shift + правый клик по пустому месту → «Открыть окно PowerShell здесь»)*.
2. Создайте виртуальное окружение:
   ```cmd
   python -m venv .venv
   ```
3. Активируйте его:
   - Командная строка (cmd):
     ```cmd
     .venv\Scripts\activate
     ```
   - PowerShell:
     ```powershell
     .venv\Scripts\Activate.ps1
     ```
     *(если PowerShell ругается на политику выполнения, выполните один раз:  
     `Set-ExecutionPolicy Unrestricted -Scope Process`)*  
4. Установите зависимости:
   ```cmd
   pip install -r requirements.txt
   ```

#### Linux / macOS

1. Откройте терминал и перейдите в папку проекта:
   ```bash
   cd /path/to/no-vibe-just-skill
   ```
2. Создайте виртуальное окружение:
   ```bash
   python3 -m venv .venv
   ```
3. Активируйте его:
   ```bash
   source .venv/bin/activate
   ```
4. Установите зависимости:
   ```bash
   pip install -r requirements.txt
   ```

---

## 4. Задача 1 — MX Checker (`mx_checker.py`)

`mx_checker.py` читает файл с email-адресами (по одному на строку), вытаскивает домен и проверяет наличие MX-записей с помощью `dnspython`.

### 4.1. Запуск

```bash
python mx_checker.py --input emails_example.txt
```

Аргументы:
- `--input` / `-i` — путь к файлу со списком адресов (по умолчанию `emails_example.txt`).

### 4.2. Статусы

Для каждой непустой строки скрипт печатает **ровно одну** строку одного из трёх видов:

- `<email>: домен валиден` — домен существует и у него есть хотя бы одна MX-запись.
- `<email>: домен отсутствует` — домен не существует или у него нет доступных DNS-серверов.
- `<email>: MX-записи отсутствуют или некорректны` — домен существует, но MX-записи не найдены или ответ некорректный.

Если адрес явно сломан (нет `@` или их больше одной), он тоже попадает в категорию `"домен отсутствует"`.  
Так проще использовать вывод для чистки списков — не нужно отдельной ветки для «битых» адресов.

### 4.3. Обработка ошибок

- Если входной файл не найден, выводится понятная ошибка и процесс завершится с кодом `1`.
- DNS-запросы выполняются с таймаутом **5 секунд**, чтобы скрипт не зависал на медленных или неправильно настроенных DNS-серверах.
- Любые неожиданные DNS/сетевые ошибки трактуются как `"MX-записи отсутствуют или некорректны"` — скрипт не падает, а аккуратно помечает проблемный домен.

---

## 5. Задача 2 — Telegram Sender (`telegram_sender.py`)

`telegram_sender.py` полностью считывает текст из указанного файла и отправляет его в Telegram-чат через Bot API.  
Все настройки берутся из переменных окружения (12-factor подход) и при локальной разработке могут приходить из файла `.env`.

### 5.1. Настройка

1. **Создайте бота и получите токен**
   - В Telegram найдите **@BotFather**.
   - Отправьте ему `/newbot` и следуйте инструкциям.
   - В ответ он пришлёт токен вида `123456:ABC-DEF...` — сохраните его.

2. **Получите свой chat_id**
   - В Telegram найдите **@userinfobot**.
   - Нажмите «Start».
   - В сообщении бот покажет поле `Id:` — это и есть `chat_id` (например, `123456789`).

3. **Настройте `.env`**
   - В корне проекта есть файл `.env.example`.
   - Скопируйте его в `.env` (или просто переименуйте).
   - Откройте `.env` в любом редакторе и подставьте свои значения:
     ```text
     TELEGRAM_BOT_TOKEN=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
     TELEGRAM_CHAT_ID=123456789
     ```
   - Сохраните файл. При запуске скрипта `python-dotenv` загрузит эти переменные окружения.

4. **Вариант без `.env` — только переменные окружения**

Можно вообще не использовать `.env`, а выставить переменные окружения вручную:

- Linux / macOS (bash/zsh):
  ```bash
  export TELEGRAM_BOT_TOKEN="123456:ABC-DEF..."
  export TELEGRAM_CHAT_ID="123456789"
  ```
- Windows PowerShell:
  ```powershell
  $env:TELEGRAM_BOT_TOKEN="123456:ABC-DEF..."
  $env:TELEGRAM_CHAT_ID="123456789"
  ```
- Windows Command Prompt (cmd):
  ```cmd
  set TELEGRAM_BOT_TOKEN=123456:ABC-DEF...
  set TELEGRAM_CHAT_ID=123456789
  ```

### 5.2. Запуск

```bash
python telegram_sender.py --input message_example.txt
```

Аргументы:
- `--input` / `-i` — путь к текстовому файлу, содержимое которого нужно отправить (по умолчанию `message_example.txt`).

### 5.3. Поведение и ошибки

- При запуске скрипт проверяет, что заданы `TELEGRAM_BOT_TOKEN` и `TELEGRAM_CHAT_ID`.  
  Если чего-то не хватает, выводится понятное сообщение и процесс завершается с кодом `1`.
- Файл с текстом читается в кодировке UTF‑8, так что русские буквы и спецсимволы никак не ломаются.
- Запрос к `https://api.telegram.org/bot<TOKEN>/sendMessage`:
  - выполняется с таймаутом **10 секунд**;
  - любая HTTP-ошибка (не `200`) печатается вместе с телом ответа;
  - дополнительно проверяется флаг `"ok"` в JSON, прежде чем считать отправку успешной.
- Любые сетевые исключения (`requests.exceptions.RequestException`) — таймауты, проблемы с DNS, обрывы соединения — перехватываются и выводятся в человекочитаемом виде.

---

## 6. Задача 3 — Архитектура (`ARCHITECTURE.md`)

Файл `ARCHITECTURE.md` описывает архитектуру рассылки примерно на **1200 адресов в сутки** с учётом:

- стратегии по доменам и ящикам (несколько доменов, несколько ящиков на домен, тёплый / активный статус);
- распределения нагрузки и суточных лимитов на домен/ящик;
- мониторинга bounce/spam-жалоб и автоматических пауз;
- рисков российских и зарубежных почтовых провайдеров;
- примерной стоимости доменов, VPS и почтовых сервисов.

Текст ориентирован на практическое использование: можно собрать подобную схему в реальной жизни с минимальными корректировками.

---

## 7. Тестирование

Решение прогонялось на небольшом, но показательном наборе сценариев:

- **MX Checker**
  - `emails_example.txt` содержит:
    - реальные потребительские домены (`gmail.com`, `ya.ru`);
    - условный домен (`example.com`);
    - заведомо несуществующий домен (`nonexistentdomain12345.com`);
    - заведомо битый адрес (`brokenemail.com`).
  - Для каждого проверено, что возвращается один из трёх ожидаемых статусов, и формат строки не «плавает».

- **Telegram Sender**
  - Успешная отправка с валидным токеном и chat_id, сообщение на русском языке.
  - Ошибочные сценарии:
    - отсутствуют `TELEGRAM_BOT_TOKEN` или `TELEGRAM_CHAT_ID`;
    - сетевые ошибки / таймауты — скрипт не падает молча, а выдаёт явное сообщение и ненулевой код выхода.

Цель тестирования — не полное покрытие всех возможных исключений, а проверка того, что скрипты ведут себя **детерминированно** и предсказуемо в типичных и проблемных сценариях.

---

## 8. Заметки о качестве

- Скрипты специально сделаны **линейными и читаемыми**: минимум «магии», максимум явных шагов.
- Внешние зависимости (`dnspython`, `requests`, `python-dotenv`) ограничены тем, без чего нельзя обойтись для DNS, HTTP и загрузки настроек.
- Таймауты и обработка ошибок подобраны исходя из сценария массовой рассылки: лучше быстро пометить адрес как проблемный, чем «повиснуть» на одном запросе.
- Все сообщения и статусы можно без доработки копировать в логи, тикеты и простые системы автоматизации.
